<h1>{{title}}</h1>
<p>{{definition}}</p>

<p>Functional programming languages focus on declarations and expressions rather than the execution of statements.
    Functions are also treated like first-class citizens—meaning they can pass as arguments, return from other
    functions, and attach to names</p>

<p>Many of today’s top programming languages—including C#, Java, JavaScript, PHP, and Python—support programming in a
    functional style or use features found in FP. </p>

<h3>Advantages of Functional Programming</h3>
<ul>
    <li><strong>Modularity</strong> – As previously mentioned, functional programming is highly modular. This makes the
        resulting code
        shorter and easier to read. Anyone who has tried to decipher monolithic code would appreciate the simplicity.
    </li>
    <li><strong>You can implement lambda calculus in the program</strong> – You can use this to solve complex problems.
    </li>
    <li><strong>Contains many functional constructs</strong> – These include lazy map, lazy evaluation, and lists.</li>
    <li><strong>Some programming languages support nested functions</strong> – This significantly improves the
        maintainability of the
        code.</li>
    <li><strong>Problems are easier to pinpoint and solve</strong> – FP’s reliance on pure functions makes debugging and
        unit testing
        easier. Pure functions also prevent confusing issues and errors from developing in the code.</li>
    <li><strong>Keeps concurrency safe</strong> – Code is thread-safe when no two concurrent processes try to access the
        same data
        simultaneously. This bug is a race condition. Since pure functions never share a state with other sections of
        the program, race conditions can’t occur.
    </li>
</ul>

<h3>Object-Oriented Programming vs Functional Programming</h3>

<p>OOP uses the imperative programming model, meaning functions are invariably coded in every step needed to solve a
    problem. You code each operation with the code itself specifying how to solve the problem. This model requires the
    programmer to know which functions are necessary to solve a problem instead of relying on models that can solve the
    problems. </p>
<p>FP uses the declarative programming model, meaning it relies on the underlying concepts of a programming language to
    execute the necessary steps to reach the predetermined outcome. </p>
<p>Imperative programs focus on the step-by-step process of solving a problem, whereas declarative programs focus on the
    result of solving a problem.</p>